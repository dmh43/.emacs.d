(ns word-search.slice)

(defn slice-right
  "Gives the index of the element to the right of the element at start-i in
  matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (when start-i
    (if (= 0 (mod (inc start-i) M))
      (when wrap 
        (* M (int (/ start-i M)))) ;; cycle could be used here to get words like "HIGH"
      (inc start-i))))

(defn slice-left
  "Gives the index of the element to the left of the element at start-i in
  matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (when start-i
    (if (= 0 (mod start-i M))
      (when wrap 
        (dec (+ start-i M)))
      (dec start-i))))

(defn slice-down
  "Gives the index of the element below the element at start-i in
  matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (when start-i
    (if (= (dec N) (int (/ start-i M)))
      (when wrap 
        (-  start-i (* M (dec N))))
      (+ M start-i))))

(defn slice-up
  "Gives the index of the element above the element at start-i in
  matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (when start-i
    (if (< start-i M)
      (when wrap 
        (+  start-i (* M (dec N))))
      (- start-i M))))

(defn slice-ur
  "Gives the index of the element above and to the right of the 
  element at start-i in matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (slice-right M N wrap (slice-up M N wrap start-i)))

(defn slice-ul
  "Gives the index of the element above and to the left of the 
  element at start-i in matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (slice-left M N wrap (slice-up M N wrap start-i)))

(defn slice-dr
  "Gives the index of the element below and to the right of the 
  element at start-i in matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (slice-right M N wrap (slice-down M N wrap start-i)))

(defn slice-dl
  "Gives the index of the element below and to the left of the 
  element at start-i in matrix with NxM dimensions with stride indexing"
  [M N wrap start-i]
  (slice-left M N wrap (slice-down M N wrap start-i)))

(defn slice-next
  "Dispatch the correct slice-next function in the correct direction"
  [dir M N wrap start-i]
  (cond
    (= dir :right)
    (slice-right M N wrap start-i)
    (= dir :left)
    (slice-left M N wrap start-i)
    (= dir :down)
    (slice-down M N wrap start-i)
    (= dir :up)
    (slice-up M N wrap start-i)
    (= dir :ur)
    (slice-ur M N wrap start-i)
    (= dir :ul)
    (slice-ul M N wrap start-i)
    (= dir :dr)
    (slice-dr M N wrap start-i)
    (= dir :dl)
    (slice-dl M N wrap start-i)))

(defn slice-indices
  "Gives a lazy sequence of indices which correspond to a slice in the
  letter matrix of prob-data in the direction dir, starting at start-i 
  using stride indexing could be organized with multimethods to dispatch 
  the lazy sequence for each direction"
  ([prob-data start-i dir]
   (slice-indices prob-data start-i dir start-i))
  ([prob-data start-i dir init-i]
   (if start-i
     (let [M (:M prob-data)
           N (:N prob-data)
           wrap (:wrap prob-data)
           next-i (slice-next dir M N wrap start-i)]
       (if (not= next-i init-i) ; checks that we have not wrapped all the way
         (cons start-i (lazy-seq (slice-indices prob-data next-i dir init-i)))
         (list start-i)))
     '())))

(defn slice-letters
  "Sequence of letters along a slice"
  [prob-data indices]
  (map (partial nth (merge-strs (:letter-matrix prob-data)))
       indices))
